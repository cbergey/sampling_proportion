<!DOCTYPE html>
<html>

<head>
	<title>Sampling experiment</title>
	<script src="https://unpkg.com/jspsych@7.1.2"></script>
	<script src="https://unpkg.com/@jspsych/plugin-image-button-response@1.1.0"></script>
	<script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.0"></script>
	<script src="https://unpkg.com/@jspsych/plugin-html-slider-response@1.1.0"></script>
	<script src="https://unpkg.com/@jspsych/plugin-image-button-response@1.1.0"></script>
	<script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1.1.0"></script>
	<script src="https://unpkg.com/@jspsych/plugin-preload@1.1.0"></script>
	<link href="https://unpkg.com/jspsych@7.1.2/css/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<body></body>
<script>

	var jsPsych = initJsPsych({
		on_finish: function () {
			jsPsych.data.displayData();
		}
	});

	shuffle = function (o) { //v1.0
		for (var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
		return o;
	}

	var conditions = ["sequential", "simultaneous"]

	var variants = [[[7, 9], [9, 17]], [[7, 16], [2, 10]], [[3, 15], [9, 11]], [[3, 8], [16, 18]], [[10, 13], [4, 13]]]

	var colors = ["orange", "green"]


	// setting a bunch of features
	conditions = shuffle(conditions);
	var condition = conditions.pop();

	colors = shuffle(colors)
	var major_color = colors.pop()
	var minor_color = colors.pop()

	variants = shuffle(variants)
	var box1props = shuffle(variants.pop())
	var box2props = shuffle(variants.pop())

	var radius = 30;

	var samplePhase = 0; //this will be 1 for phase 1, 2 for phase 2; initializing to 0
	var curTrial = 0; //so that we can track the sample number for the sequential condition

	//making the stimuli and functions for drawing stimuli
	//first, make the list of colors; this will be used for the order of stim in the sequential and simultaneous versions
	function makeTrials(numerator, denominator, pos_value, neg_value) {
		var pos_vals = Array(numerator).fill(pos_value)
		var neg_vals = Array((denominator - numerator)).fill(neg_value)
		var stims = shuffle(pos_vals.concat(neg_vals))
		return (stims)
	}

	var box_one_phase_one_list = makeTrials(box1props[0][0], box1props[0][1], major_color, minor_color)
	var box_one_phase_two_list = makeTrials(box1props[1][0], box1props[1][1], major_color, minor_color)
	var box_two_phase_one_list = makeTrials(box2props[0][0], box2props[0][1], major_color, minor_color)
	var box_two_phase_two_list = makeTrials(box2props[1][0], box2props[1][1], major_color, minor_color)

	if (condition == "sequential") {
		var drawCondition = drawOneDot;
		var box1phase1Details = box_one_phase_one_list;
		var box1phase2Details = box_one_phase_two_list;
		var box2phase1Details = box_two_phase_one_list;
		var box2phase2Details = box_two_phase_two_list;
	};
	if (condition == "simultaneous") {
		var drawCondition = drawAllDotsRandom;
		//because of the way the stimulus variable works to get number of repeats for trials
		//there's probably a better way, but this works
		var box1phase1Details = [
			{ num: box1props[0][0], den: box1props[0][1] }
		];
		var box1phase2Details = [
			{ num: box1props[1][0], den: box1props[1][1] }
		];
		var box2phase1Details = [
			{ num: box2props[0][0], den: box2props[0][1] }
		];
		var box2phase2Details = [
			{ num: box2props[1][0], den: box2props[1][1] }
		];
	};


	//function for sequntial condition
	function drawOneDot(c) {
		// set parameters for dot
		var onlyDot = {
			x: 300,
			y: 200,
			radius: radius,
			color: current_list[curTrial]
		}

		var ctx = c.getContext(`2d`);
		//draw the dot
		ctx.beginPath();
		ctx.moveTo(onlyDot.x, onlyDot.y);
		ctx.arc(onlyDot.x, onlyDot.y, radius, 0, Math.PI * 2);
		ctx.fillStyle = onlyDot.color;
		ctx.fill();
		ctx.closePath();
	};

	function drawAllDotsGrid(c) {
		// initialize with first dot
		var dots = [];
		var firstDot = {
			x: 140 + 10 + radius,
			y: 10 + radius,
			radius: radius,
			color: current_list[0]
		}
		dots.push(firstDot)
		for (var d = 1; d < current_list.length; d++) {
			var dot = {
				x: (140 + 10 + radius) + (radius * 2 + 10) * (d % 4),
				y: (10 + radius) + (radius * 2 + 10) * (Math.floor(d / 4)),
				radius: radius,
				color: current_list[d]
			}
			dots.push(dot)
		}

		var ctx = c.getContext(`2d`);

		//draw each dot
		for (d = 0; d < current_list.length; d++) {
			ctx.beginPath();
			ctx.moveTo(dots[d].x, dots[d].y);
			ctx.arc(dots[d].x, dots[d].y, radius, 0, Math.PI * 2);
			ctx.fillStyle = dots[d].color;
			ctx.fill();
			ctx.closePath();
		}
	};

	function drawAllDotsRandom(c) {

		// initialize with first dot
		var dots = [];
		var check = 0;
		var gap = 10;
		// until we have all the dots we need for this stimulus
		while (dots.length < current_list.length) {

			// creates a dot variable that includes the x and y positions and some basic data about what stim that dot will become part of
			var dot = {
				x: Math.floor(Math.random() * (600 - 2 * radius) + radius),
				y: Math.floor(Math.random() * (600 - 2 * radius) + radius),
				radius: radius
			}

			// now checking for overlap between the dot we just made above and the previously made dots
			// assume overlap is false, check overlap, update to true if needed only
			var overlap = false;

			for (var i = 0; i < dots.length; i++) {
				var newDot = dots[i]
				// distance is between the centers of the two dots
				// this distance needs to be larger than the radii of each dot + the required minimum gap
				function dist(x1, x2, y1, y2) {
					return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
				};
				var distance = dist(dot.x, newDot.x, dot.y, newDot.y);
				if (distance < dot.radius + newDot.radius + gap) {
					overlap = true;
					break;
				}
			}
			// if overlap is false, then we push the dot we created to the list
			if (!overlap) {
				dots.push(dot);
			}
			check++;

			if (check > 10000) {
				break;
			}
		}
		var ctx = c.getContext(`2d`);

		//draw each dot
		for (d = 0; d < current_list.length; d++) {
			ctx.beginPath();
			ctx.moveTo(dots[d].x, dots[d].y);
			ctx.arc(dots[d].x, dots[d].y, radius, 0, Math.PI * 2);
			ctx.fillStyle = current_list[d];
			ctx.fill();
			ctx.closePath();
		}
	};

	// initialize timeline and push each aspect of procedure as we go
	var timeline = [];
	// preloading images - but we can remove this if we're drawing dots instead, right?
	//but maybe need to pre-load the image of a box if we're using that?
	var preload = {
		type: jsPsychPreload,
		images: ['stim_images/orange_dot.png', 'stim_images/green_dot.png']
	};
	timeline.push(preload);

	// overall task instructions
	var instructions = {
		type: jsPsychHtmlButtonResponse,
		stimulus: `
  		<p>You will see boxes with different colored balls in them. We will show you some of the balls from the box and then ask you questions about what you think the box is like. </p>
    	`,
		choices: ['Next'],
		post_trial_gap: 1000
	};

	timeline.push(instructions)


	// *********** BOX ONE *********** //

	//need to make the box1_details 
	// 	box1_details
	// needs to include:
	// “instruction_phrase” for each sample
	// “num_dv_phrase” for each sample
	// “rem_dv_phrase” for each sample
	// “current_list” —> the name of the list of green/orange

	// instructions for drawing sample 1, i.e., phase one
	phase_one_instructions = "<p>In this box, there are " + major_color + " balls and " + minor_color + " balls. Now we will show you some of the balls in the box, but not all of the balls.  </p>"
	numerator_q_1 = "<p>Remember, that was just some of the balls from the box. What proportion of the balls in the box do you think are " + major_color + "?</p>"
	denominator_q_1 = "<p>What proportion of the balls in the box do you think are " + minor_color + "?</p>"


	var instructions = {
		type: jsPsychHtmlButtonResponse,
		stimulus: jsPsych.timelineVariable(`instruction_phrase`),
		choices: ['Next'],
		post_trial_gap: 1000,
		on_start: function () {
			samplePhase = 1;
		}
	};

	// sample 1, phase 1 - stim presentation procedure

	var current_list = box_one_phase_one_list
	var dot_display = {
		type: jsPsychCanvasKeyboardResponse,
		canvas_size: [600, 600],
		stimulus: drawCondition,
		choices: ` `, //this is space
		post_trial_gap: 500,
		on_finish: function () {
			curTrial++;
		},
		timeline: function () {
			if (condition == "sequential") {
				return current_list//a timeline with denominator number of elements, one for each dot
			}
			if (condition == "simultaneous") {
				return [current_list]// a timeline with one element, with the needed information about each dot
			}
		}
	}

	var numerator_dv = {
		type: jsPsychHtmlSliderResponse,
		labels: ['None (0%)', 'All (100%)'],
		stimulus: "",
		slider_width: 500,
		require_movement: true,
		prompt: jsPsych.timelineVariable(`num_dv_phrase`)
	};

	var remainder_dv = {
		type: jsPsychHtmlSliderResponse,
		labels: ['None (0%)', 'All (100%)'],
		stimulus: "",
		slider_width: 500,
		require_movement: true,
		prompt: jsPsych.timelineVariable(`rem_dv_phrase`)
	};

	var sample_procedure = {
		timeline: [instructions, dot_display, numerator_dv, remainder_dv],
		timeline_variables: box1_phrases
	}

	timeline.push(sample_procedure)

	// DVs after the first sample, i.e., phase 1

	//phase 2 begins
	//phase 2 instructions
	phase_two_instructions = "<p>Now we will show you more balls from the same box.</p>"

	var phase_two_instructions = {
		type: jsPsychHtmlButtonResponse,
		stimulus: phase_two_instructions,
		choices: ['Next'],
		post_trial_gap: 1000,
		on_start: function () {
			samplePhase = 2;
			curTrial = 0; //resetting to 0 for phase 2, but needed only for sequential condition
		}
	};

	timeline.push(phase_two_instructions)

	//sample 2; i.e., phase 2 - stim presentation procedure
	var current_list = box_one_phase_two_list
	var phase_two_display = {
		type: jsPsychCanvasKeyboardResponse,
		canvas_size: [600, 600],
		stimulus: drawCondition,
		choices: ` `, //this is space
		post_trial_gap: 500,
		on_finish: function () {
			curTrial++;
		}
	}

	var phase_two_procedure = {
		timeline: [phase_two_display],
		timeline_variables: box1phase2Details
	}

	timeline.push(phase_two_procedure)
	// DVs after the second sample, i.e., phase 2
	numerator_q_2 = "<p>Now that you’ve seen even more balls from the box, what proportion of the balls in the box do you think are " + major_color + "?</p>"
	denominator_q_2 = "<p>What proportion of the balls in the box do you think are " + minor_color + "?</p>"

	var numerator_dv_2 = {
		type: jsPsychHtmlSliderResponse,
		labels: ['None (0%)', 'All (100%)'],
		stimulus: "",
		slider_width: 500,
		require_movement: true,
		prompt: numerator_q_2
	};

	var denominator_dv_2 = {
		type: jsPsychHtmlSliderResponse,
		labels: ['None (0%)', 'All (100%)'],
		stimulus: "",
		slider_width: 500,
		require_movement: true,
		prompt: denominator_q_2
	};
	timeline.push(numerator_dv_2)
	timeline.push(denominator_dv_2)

	// **************** BOX TWO ***************** //

	box_two_phase_one_instructions = "<p>Now you'll see balls from a new box. This box is unrelated to the first one. In this box, there are " + major_color + " balls and " + minor_color + " balls. Now we will show you some of the balls in the box, but not all of the balls.  </p>"

	var box_two_phase_one_instructions = {
		type: jsPsychHtmlButtonResponse,
		stimulus: box_two_phase_one_instructions,
		choices: ['Next'],
		post_trial_gap: 1000,
		on_start: function () {
			samplePhase = 1;
		}
	};

	timeline.push(box_two_phase_one_instructions)

	// first phase of sampling for box 2
	var current_list = box_two_phase_one_list
	var box_two_phase_one_procedure = {
		timeline: [phase_one_display],
		timeline_variables: box2phase1Details
	}

	timeline.push(box_two_phase_one_procedure)

	// DVs
	timeline.push(numerator_dv_1)
	timeline.push(denominator_dv_1)

	timeline.push(phase_two_instructions)

	// second phase of sampling for box 2
	var current_list = box_two_phase_two_list
	var box_two_phase_two_procedure = {
		timeline: [phase_two_display],
		timeline_variables: box2phase2Details
	}

	timeline.push(box_two_phase_two_procedure)

	timeline.push(numerator_dv_2)
	timeline.push(denominator_dv_2)

	jsPsych.run(timeline);
</script>

</html>